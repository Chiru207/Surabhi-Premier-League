<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"/>
  <title>Live Auction - {{EVENT_NAME}}</title>
  <link rel="stylesheet" href="style.css">
  <style>
  /* Responsive font sizing for live page */
  .live-h3 { font-size: clamp(20px, 4vw, 28px); }
  .live-h2 { font-size: clamp(24px, 5vw, 40px); }
  .live-h4 { font-size: clamp(16px, 3vw, 22px); }
  .live-p { font-size: clamp(16px, 3vw, 22px); }
  .live-tag { font-size: clamp(12px, 2vw, 16px); }
  .live-countdown { font-size: clamp(20px, 4vw, 32px); }
  .live-bid-amount { font-size: clamp(18px, 3.5vw, 26px); }
  .live-caption { font-size: clamp(14px, 2.5vw, 18px); }
  
  @media (min-width: 768px) {
    .live-h3 { font-size: 28px; }
    .live-h2 { font-size: 40px; }
    .live-h4 { font-size: 22px; }
    .live-p { font-size: 22px; }
    .live-tag { font-size: 16px; }
    .live-countdown { font-size: 32px; }
    .live-bid-amount { font-size: 26px; }
    .live-caption { font-size: 18px; }
  }
  
  @media (min-width: 1024px) {
    .live-h3 { font-size: 32px; }
    .live-h2 { font-size: 48px; }
    .live-h4 { font-size: 24px; }
    .live-p { font-size: 24px; }
    .live-tag { font-size: 18px; }
    .live-countdown { font-size: 36px; }
    .live-bid-amount { font-size: 30px; }
    .live-caption { font-size: 20px; }
  }
  
  /* Responsive bidding log - stack on mobile */
  @media (max-width: 1023px) {
    #biddingLogContainer {
      flex: 1 1 100% !important;
      min-width: 100% !important;
      max-width: 100% !important;
      margin-top: 16px;
    }
  }
  
  /* Larger fonts for captain status banner on live page */
  #captainBanner .banner-captain-name {
    font-size: clamp(16px, 3vw, 24px) !important;
    font-weight: 700 !important;
  }
  #captainBanner .banner-captain-stat {
    font-size: clamp(14px, 2.5vw, 20px) !important;
  }
  #captainBanner .banner-captain-stat strong {
    font-size: clamp(16px, 3vw, 22px) !important;
    font-weight: 700 !important;
  }
  #captainBanner .banner-title {
    font-size: clamp(16px, 3vw, 22px) !important;
    font-weight: 700 !important;
  }
  
  @media (min-width: 768px) {
    #captainBanner .banner-captain-name { font-size: 22px !important; }
    #captainBanner .banner-captain-stat { font-size: 18px !important; }
    #captainBanner .banner-captain-stat strong { font-size: 20px !important; }
    #captainBanner .banner-title { font-size: 20px !important; }
  }
  
  @media (min-width: 1024px) {
    #captainBanner .banner-captain-name { font-size: 24px !important; }
    #captainBanner .banner-captain-stat { font-size: 20px !important; }
    #captainBanner .banner-captain-stat strong { font-size: 22px !important; }
    #captainBanner .banner-title { font-size: 22px !important; }
  }
  
  /* Connection status indicator */
  #connectionStatus {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    z-index: 1000;
    transition: all 0.3s;
  }
  #connectionStatus.connected {
    background: #10b981;
    color: white;
  }
  #connectionStatus.disconnected {
    background: #ef4444;
    color: white;
  }
  #connectionStatus.connecting {
    background: #fbbf24;
    color: #000;
  }
  </style>
</head>
<body>
  <div id="connectionStatus" class="connecting">Connecting...</div>
  <header>
    <h2>Live Viewer - <span id="eventName">Surabhi Premier League 2025</span></h2>
    <div style="margin-top:8px">
      <a href="index.html" style="color:#60a5fa;text-decoration:none;font-size:14px">‚Üê Back to Home</a>
    </div>
  </header>
  <div class="banner" id="captainBanner">
    <div class="banner-title">Captain Status</div>
    <div class="banner-captains" id="bannerCaptains"></div>
  </div>
  <main>
  <!-- Current Bidding - Top with larger font -->
  <div class="card" id="now" style="margin-bottom:24px"></div>
  <div class="card" id="announcement" style="display:none;margin-bottom:24px">
    <div id="announcementContent"></div>
  </div>
  <div class="card" id="roundSummary" style="margin-bottom:24px">
    <h3 class="live-h3">Bidding Rounds Summary</h3>
    <div id="roundSummaryContent"></div>
  </div>
  <!-- Teams Information - Below -->
  <div class="card" id="teamsCard" style="display:none;margin-bottom:24px">
    <h3 class="live-h3">Team Rosters</h3>
    <div id="teamTabs" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px;border-bottom:2px solid #334155;padding-bottom:12px"></div>
    <div id="teamContent"></div>
  </div>
  <div class="card"><h3 class="live-h3">Recent Results</h3><div id="recent"></div></div>
  <div class="card"><h3 class="live-h3">Logs</h3><div id="logs" style="max-height:400px;overflow-y:auto;font-size:14px;line-height:1.6"></div></div>
  </main>
  
  <!-- Socket.IO Client Library - Load from CDN -->
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
  // Configuration: Get server URL from URL parameter, window variable, or auto-detect
  // Priority:
  // 1. URL parameter: ?server=https://abc123.ngrok.io (RECOMMENDED for GitHub Pages)
  // 2. window.SERVER_URL (set before loading page)
  // 3. Auto-detect from current page URL (if accessed from same server)
  // 4. Default to localhost (for local development)
  const urlParams = new URLSearchParams(window.location.search);
  let SERVER_URL = urlParams.get('server') || window.SERVER_URL;
  
  // Auto-detect: if accessed from same origin, use current origin
  if (!SERVER_URL) {
    const currentOrigin = window.location.origin;
    const currentPort = window.location.port;
    // If accessed from the same server (not localhost), use current origin
    // Otherwise, default to localhost for local development
    if (currentOrigin.includes('localhost') || currentOrigin.includes('127.0.0.1')) {
      // For localhost, use port 3000 (default server port)
      SERVER_URL = 'http://localhost:3000';
    } else {
      // Use the same origin (works if live-standalone.html is served from the same server)
      // If port is specified, keep it; otherwise use default
      if (currentPort && currentPort !== '80' && currentPort !== '443') {
        SERVER_URL = currentOrigin;
      } else {
        // No port specified, use current origin (will use default port)
        SERVER_URL = currentOrigin;
      }
    }
  }
  
  // If SERVER_URL is still not set, show helpful error
  if (!SERVER_URL) {
    console.error('‚ùå SERVER_URL not configured!');
    console.error('For GitHub Pages, use: ?server=https://your-ngrok-url.ngrok.io');
    alert('Server URL not configured. Please add ?server=YOUR_SERVER_URL to the page URL.\n\nExample: ?server=https://abc123.ngrok.io');
  }
  
  console.log('üîç Auto-detected SERVER_URL:', SERVER_URL);
  console.log('üìç Current page origin:', window.location.origin);
  
  console.log('Connecting to server:', SERVER_URL);
  
  // Initialize Socket.IO connection to remote server
  const sock = io(SERVER_URL, {
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: Infinity,
    timeout: 20000
  });
  
  // Connection status management
  const statusEl = document.getElementById('connectionStatus');
  
  sock.on('connect', () => {
    statusEl.textContent = 'Connected';
    statusEl.className = 'connected';
    console.log('‚úÖ Connected to server:', SERVER_URL);
    // Send hello to identify as viewer - server will send initial state
    sock.emit('hello', { role: 'viewer' });
  });
  
  sock.on('disconnect', () => {
    statusEl.textContent = 'Disconnected';
    statusEl.className = 'disconnected';
    console.log('Disconnected from server');
  });
  
  sock.on('connect_error', (error) => {
    statusEl.textContent = 'Connection Error - Check console';
    statusEl.className = 'disconnected';
    console.error('‚ùå Connection error:', error);
    console.error('Attempted to connect to:', SERVER_URL);
    console.error('Current page URL:', window.location.href);
    console.error('If this persists, try accessing with: ?server=http://YOUR_SERVER_IP:3000');
  });
  
  sock.on('reconnect', (attemptNumber) => {
    statusEl.textContent = 'Reconnected';
    statusEl.className = 'connected';
    console.log('Reconnected after', attemptNumber, 'attempts');
    sock.emit('hello', { role: 'viewer' });
  });
  
  sock.on('reconnect_attempt', () => {
    statusEl.textContent = 'Reconnecting...';
    statusEl.className = 'connecting';
  });
  
  // Track current player serial for bidding log
  let currentPlayerSerial = null;
  
  // Track previous state for sound triggers
  let previousState = {
    currentIndex: null,
    players: [],
    logs: [],
    lastTimerSecond: null,
    soldPlayers: new Set()
  };
  
  // Shared audio context for better performance
  let audioContext = null;
  function getAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    return audioContext;
  }
  
  // Sound effects using Web Audio API
  function playSound(type) {
    try {
      const ctx = getAudioContext();
      
      let frequency = 440;
      let duration = 0.1;
      let volume = 0.3;
      
      switch(type) {
        case 'bid':
          // Short beep for bid
          frequency = 600;
          duration = 0.15;
          volume = 0.2;
          break;
        case 'basePrice':
          // Medium beep for base price claim
          frequency = 500;
          duration = 0.2;
          volume = 0.25;
          break;
        case 'drop':
          // Lower tone for drop
          frequency = 300;
          duration = 0.2;
          volume = 0.2;
          break;
        case 'sold':
          // Clapping-like sound (multiple tones)
          playClappingSound(ctx);
          return;
        case 'newPlayer':
          // Upward tone for new player
          frequency = 400;
          duration = 0.3;
          volume = 0.3;
          break;
        case 'adminAction':
          // Notification sound
          frequency = 350;
          duration = 0.25;
          volume = 0.25;
          break;
        case 'timerWarning':
          // Warning beep
          frequency = 800;
          duration = 0.1;
          volume = 0.3;
          break;
      }
      
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(volume, ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
      
      oscillator.start(ctx.currentTime);
      oscillator.stop(ctx.currentTime + duration);
    } catch (e) {
      console.log('Sound playback not available:', e);
    }
  }
  
  // Clapping-like sound (multiple quick tones in a chord pattern)
  function playClappingSound(audioContext) {
    // Play a celebratory chord sequence (C major chord)
    const chord1 = [523, 659, 784]; // C, E, G
    const chord2 = [523, 659, 784, 1047]; // C, E, G, C (octave)
    
    // First chord
    chord1.forEach((freq, index) => {
      setTimeout(() => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = freq;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      }, index * 30);
    });
    
    // Second chord (slightly delayed for clapping effect)
    setTimeout(() => {
      chord2.forEach((freq, index) => {
        setTimeout(() => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = freq;
          oscillator.type = 'sine';
          
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.15);
        }, index * 25);
      });
    }, 150);
  }
  
  // Text-to-speech announcement
  function speak(text, priority = 'normal') {
    if ('speechSynthesis' in window) {
      // Cancel any ongoing speech
      if (priority === 'high') {
        window.speechSynthesis.cancel();
      }
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.9;
      utterance.pitch = 1.0;
      utterance.volume = 0.8;
      utterance.lang = 'en-US';
      
      window.speechSynthesis.speak(utterance);
    }
  }
  
  // Initialize audio on user interaction
  document.addEventListener('click', function initAudio() {
    getAudioContext();
  }, { once: true });
  
  function updateBanner(st) {
    const bannerEl = document.getElementById('bannerCaptains');
    if(!bannerEl) return;
    if(!st.captains || st.captains.length === 0) {
      bannerEl.innerHTML = '<div style="color:#94a3b8;padding:8px">No captains joined yet</div>';
      return;
    }
    bannerEl.innerHTML = st.captains.map(c => 
      '<div class="banner-captain">' +
        '<div class="banner-captain-name">' + c.name + '</div>' +
        '<div class="banner-captain-stat">Players: <strong>' + c.teamCount + '</strong></div>' +
        '<div class="banner-captain-stat">Remaining: <strong>' + c.remaining + '</strong></div>' +
        '<div class="banner-captain-stat">Max Bid: <strong>' + c.maxAllowedBid + '</strong></div>' +
      '</div>'
    ).join('');
  }
  
  function renderTeams(st) {
    if (!st.captains || st.captains.length === 0) {
      const teamsCard = document.getElementById('teamsCard');
      if (teamsCard) teamsCard.style.display = 'none';
      return;
    }
    
    const teamsCard = document.getElementById('teamsCard');
    const teamTabs = document.getElementById('teamTabs');
    const teamContent = document.getElementById('teamContent');
    
    if (!teamsCard || !teamTabs || !teamContent) return;
    
    teamsCard.style.display = 'block';
    
    // Get queued players count for "Next Round" tab
    const queuedPlayers = st.players.filter(p => p.status === 'queued');
    const queuedCount = queuedPlayers.length;
    
    // Create tabs for each captain + "Next Round" tab
    const tabs = st.captains.map(c => ({
      id: c.id,
      name: c.name + ' (' + c.teamCount + ')',
      active: false
    }));
    
    // Add "Next Round" tab
    tabs.push({ id: 'nextRound', name: 'Next Round (' + queuedCount + ')', active: false });
    
    // Set first tab as active
    if (tabs.length > 0) tabs[0].active = true;
    
    teamTabs.innerHTML = tabs.map(tab => 
      '<button class="btn ' + (tab.active ? '' : 'alt') + '" onclick="switchTeamTab(\'' + tab.id + '\')" style="margin-bottom:8px;min-width:120px">' + tab.name + '</button>'
    ).join('');
    
    // Render team content
    function renderTeamContent(activeTabId) {
      if (activeTabId === 'nextRound') {
        // Show players moved to next round
        const nextRoundPlayers = st.players.filter(p => p.status === 'queued');
        if (nextRoundPlayers.length === 0) {
          teamContent.innerHTML = '<div style="color:#94a3b8;padding:16px;text-align:center">No players in next round yet</div>';
        } else {
          teamContent.innerHTML = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px">' +
            nextRoundPlayers.map(p => {
              const img = p.photoFile && st.photoBase ? '<img class="photo" src="' + st.photoBase + encodeURIComponent(p.photoFile) + '" onerror="this.remove()" style="width:100%;height:auto;border-radius:8px;margin-bottom:8px"/>' : '';
              return '<div class="card" style="padding:12px">' +
                img +
                '<div class="tag">#' + p.serial + '</div>' +
                '<div class="tag">' + (p.role||'') + '</div>' +
                '<h4>' + p.name + '</h4>' +
                '<div style="color:#fbbf24;font-weight:600">Round ' + (p.round || 1) + '</div>' +
              '</div>';
            }).join('') +
          '</div>';
        }
      } else {
        // Show captain's team
        const captain = st.captains.find(c => c.id === activeTabId);
        if (!captain) {
          teamContent.innerHTML = '<div style="color:#94a3b8;padding:16px">Captain not found</div>';
          return;
        }
        
        // Filter players by soldToCaptainId and status === 'sold' (same approach as live.html)
        const boughtPlayers = st.players.filter(p => p.soldToCaptainId === captain.id && p.status === 'sold');
        boughtPlayers.sort((a, b) => (a.serial || 0) - (b.serial || 0));
        
        if (boughtPlayers.length === 0) {
          teamContent.innerHTML = '<div style="color:#94a3b8;padding:16px;text-align:center">No players bought yet</div>';
        } else {
          teamContent.innerHTML = '<div style="margin-top:16px">' +
            '<h4 class="live-h4" style="color:#60a5fa;margin-bottom:12px">' + captain.name + '\'s Team (' + boughtPlayers.length + ' players)</h4>' +
            '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px">' +
              boughtPlayers.map(p => {
                const price = p.currentBid || p.basePrice || 0;
                const img = p.photoFile && st.photoBase ? '<img class="photo" src="' + st.photoBase + encodeURIComponent(p.photoFile) + '" onerror="this.remove()" style="width:100%;height:auto;border-radius:8px;margin-bottom:8px"/>' : '';
                return '<div class="card" style="padding:12px">' +
                  img +
                  '<div class="tag">#' + p.serial + '</div>' +
                  '<div class="tag">' + (p.role||'') + '</div>' +
                  '<h4>' + p.name + '</h4>' +
                  '<div style="color:#10b981;font-weight:600">' + price + '</div>' +
                '</div>';
              }).join('') +
            '</div>' +
          '</div>';
        }
      }
    }
    
    // Store active tab and render function
    window.activeTeamTab = tabs[0].id;
    window.switchTeamTab = function(tabId) {
      window.activeTeamTab = tabId;
      
      // Update tab active states
      tabs.forEach(tab => tab.active = (tab.id === tabId));
      
      // Recalculate team counts for tabs (in case they changed)
      const currentQueuedCount = st.players.filter(p => p.status === 'queued').length;
      tabs.forEach(tab => {
        if (tab.id === 'nextRound') {
          tab.name = 'Next Round (' + currentQueuedCount + ')';
        } else {
          const cap = st.captains.find(c => c.id === tab.id);
          if (cap) {
            tab.name = cap.name + ' (' + cap.teamCount + ')';
          }
        }
      });
      
      teamTabs.innerHTML = tabs.map(tab => 
        '<button class="btn ' + (tab.active ? '' : 'alt') + '" onclick="switchTeamTab(\'' + tab.id + '\')" style="margin-bottom:8px;min-width:120px">' + tab.name + '</button>'
      ).join('');
      
      renderTeamContent(tabId);
    };
    
    renderTeamContent(window.activeTeamTab);
  }
  
  function getBiddingLogHtml(st) {
    if (st.currentIndex == null || currentPlayerSerial == null) {
      return '';
    }
    
    const p = st.players[st.currentIndex];
    if (!p) {
      return '';
    }
    
    const playerLogs = (st.logs || []).filter(log => {
      const msg = log.msg || '';
      const serial = p.serial;
      const name = p.name;
      
      return msg.includes('Serial ' + serial) || 
             msg.includes('Serial #' + serial) ||
             msg.includes('(' + name + ')') ||
             msg.includes(name + ' (Serial') ||
             (msg.includes('BID:') && msg.includes(name)) ||
             (msg.includes('BASE PRICE') && msg.includes(name)) ||
             (msg.includes('DROP:') && msg.includes(name)) ||
             (msg.includes('SOLD:') && msg.includes(name)) ||
             (msg.includes('FINISHED') && msg.includes(name)) ||
             (msg.includes('MOVED TO NEXT ROUND') && msg.includes(name));
    }).slice(-20).reverse();
    
    if (playerLogs.length === 0) {
      return '';
    }
    
    return '<div style="background:#1e293b;border:1px solid #334155;border-radius:8px;padding:12px;max-height:400px;overflow-y:auto">' +
      '<div style="color:#fbbf24;font-weight:600;margin-bottom:8px;font-size:14px">Bidding Log</div>' +
      '<div id="biddingLogContent" style="font-size:12px;line-height:1.8;color:#cbd5e1">' +
        playerLogs.map(log => {
          let msg = log.msg || '';
          // Clean up log messages for display
          msg = msg.replace(/BID: /g, 'üí∞ ');
          msg = msg.replace(/BASE PRICE CLAIMED: /g, '‚úÖ ');
          msg = msg.replace(/DROP: /g, '‚ùå ');
          msg = msg.replace(/SOLD: /g, 'üéâ ');
          msg = msg.replace(/FINISHED \(Admin\): /g, 'üèÅ ');
          msg = msg.replace(/MOVED TO NEXT ROUND/g, '‚è≠Ô∏è ');
          msg = msg.replace(/TIMER PAUSED by /g, '‚è∏Ô∏è ');
          msg = msg.replace(/TIMER RESUMED by /g, '‚ñ∂Ô∏è ');
          return '<div style="margin-bottom:4px;padding:4px;border-left:2px solid #334155;padding-left:8px">' +
            '<span style="color:#94a3b8;font-size:11px">' + (log.ts || '') + '</span> ' +
            '<span>' + msg + '</span>' +
          '</div>';
        }).join('') +
      '</div>' +
    '</div>';
  }
  
  function scrollBiddingLog() {
    const logContent = document.getElementById('biddingLogContent');
    if (logContent) {
      setTimeout(() => {
        logContent.scrollTop = logContent.scrollHeight;
      }, 100);
    }
  }
  
  function render(st){
    window.currentState = st;
    updateBanner(st);
    
    // Update event name
    if (st.eventName) {
      document.getElementById('eventName').textContent = st.eventName;
    }
    
    // Check for state changes and trigger sounds/announcements
    checkStateChanges(st);
    
    // Check if player changed - reset bidding log
    const newPlayerSerial = st.currentIndex != null ? st.players[st.currentIndex]?.serial : null;
    if (newPlayerSerial !== currentPlayerSerial) {
      currentPlayerSerial = newPlayerSerial;
      const logEl = document.getElementById('biddingLogContent');
      if (logEl) logEl.innerHTML = '';
    }
    
    const curHtml = (()=>{
      if(st.currentIndex==null) return '<h3 class="live-h3" style="margin-bottom:16px">Waiting for next player‚Ä¶</h3>';
      const p = st.players[st.currentIndex];
      
      const isReady = p.status === 'ready';
      const img = p.photoFile && st.photoBase ? '<img class="photo" src="' + st.photoBase + encodeURIComponent(p.photoFile) + '" onerror="this.remove()"/>' : '';
      const left = p.biddingEndsAt ? Math.max(0, p.biddingEndsAt - Date.now()) : 0;
      const secs = Math.ceil(left/1000);
      
      if (isReady) {
        const currentRound = p.round || 1;
        return '<h3 class="live-h3" style="margin-bottom:16px">Player Ready (Round ' + currentRound + ')</h3>' +
          '<div style="padding:16px;background:#1e293b;border:1px solid #334155;border-radius:8px;margin-bottom:16px;color:#fbbf24;" class="live-caption">' +
            '<strong>‚è∏Ô∏è Waiting for admin to start bidding...</strong>' +
          '</div>' +
          '<div class="row">' +
            (img ? '<div style="min-width:220px;max-width:220px">' + img + '</div>' : '') +
            '<div style="flex:1">' +
              '<div class="tag live-tag" style="padding:4px 10px">Serial #' + p.serial + '</div>' +
              '<div class="tag live-tag" style="padding:4px 10px">' + (p.role||'') + '</div>' +
              '<h2 class="live-h2" style="margin:12px 0">' + p.name + '</h2>' +
              '<p class="live-p">Base: <b class="live-bid-amount">' + p.basePrice + '</b></p>' +
            '</div>' +
          '</div>';
      }
      
      // Check if player is actually in 'bidding' status
      const isBidding = p.status === 'bidding';
      
      if (!isBidding) {
        // Player is not in bidding status (could be queued, pending, etc.)
        const currentRound = p.round || 1;
        return '<h3 class="live-h3" style="margin-bottom:16px">Player Status: ' + (p.status || 'unknown') + '</h3>' +
          '<div class="row">' +
            (img ? '<div style="min-width:220px;max-width:220px">' + img + '</div>' : '') +
            '<div style="flex:1">' +
              '<div class="tag live-tag" style="padding:4px 10px">Serial #' + p.serial + '</div>' +
              '<div class="tag live-tag" style="padding:4px 10px">' + (p.role||'') + '</div>' +
              '<h2 class="live-h2" style="margin:12px 0">' + p.name + '</h2>' +
              '<p class="live-p">Base: <b class="live-bid-amount">' + p.basePrice + '</b></p>' +
            '</div>' +
          '</div>';
      }
      
      const biddingLogHtml = getBiddingLogHtml(st);
      const isPaused = p.pausedBy && Object.keys(p.pausedBy).length > 0;
      const isFrozen = st.frozen || false;
      let pausedByCaptainName = null;
      if (isPaused) {
        const pausedByCaptainId = Object.keys(p.pausedBy)[0];
        const pausedByCaptain = st.captains.find(c => c.id === pausedByCaptainId);
        pausedByCaptainName = pausedByCaptain ? pausedByCaptain.name : pausedByCaptainId;
      }
      
      const currentRound = p.round || 1;
      return '<h3 class="live-h3" style="margin-bottom:16px">Now Bidding (Round ' + currentRound + ')</h3>' +
        '<div class="row" style="align-items:flex-start;gap:20px">' +
          '<div style="flex:1;min-width:0">' +
            '<div class="row">' +
              (img ? '<div style="min-width:220px;max-width:220px;flex-shrink:0">' + img + '</div>' : '') +
              '<div style="flex:1;min-width:0">' +
                '<div class="tag live-tag" style="padding:4px 10px">Serial #' + p.serial + '</div>' +
                '<div class="tag live-tag" style="padding:4px 10px">' + (p.role||'') + '</div>' +
                '<h2 class="live-h2" style="margin:12px 0">' + p.name + '</h2>' +
                '<p class="live-p">Base: <b class="live-bid-amount">' + p.basePrice + '</b> | Current: <b class="live-bid-amount" style="color:#60a5fa">' + Math.max(p.currentBid||0, p.basePrice||0) + '</b></p>' +
                '<p class="live-p">Leader: <b class="live-bid-amount" style="color:#10b981">' + ((st.captains.find(c=>c.id===p.currentBidderId)||{}).name||'-') + '</b></p>' +
                (isPaused && pausedByCaptainName ? '<p class="live-p" style="color:#fbbf24;font-weight:600">‚è∏Ô∏è Timer paused by: <b>' + pausedByCaptainName + '</b></p>' : isFrozen ? '<p class="live-p" style="color:#fbbf24;font-weight:600">‚è∏Ô∏è Timer frozen by Admin</p>' : '') +
              '</div>' +
            '</div>' +
          '</div>' +
          (biddingLogHtml ? '<div style="flex:0 0 350px;min-width:300px;max-width:400px" id="biddingLogContainer">' + biddingLogHtml + '</div>' : '') +
        '</div>';
    })();
    document.getElementById('now').innerHTML = curHtml;
    
    scrollBiddingLog();
    
    // Update logs display
    const logsEl = document.getElementById('logs');
    if (logsEl) {
      logsEl.innerHTML = (st.logs || []).slice().reverse().map(l => 
        '<div class="tag" style="display:inline-block;margin-right:8px;margin-bottom:4px">' + l.ts + '</div> ' + l.msg
      ).join('<br/>');
      logsEl.scrollTop = 0;
    }
    
    // Announcement card - Show when player is moved to next round
    const announcementCard = document.getElementById('announcement');
    const announcementContent = document.getElementById('announcementContent');
    if (announcementCard && announcementContent) {
      // First check if current player was moved to next round
      const currentPlayer = st.currentIndex != null ? st.players[st.currentIndex] : null;
      const playerMovedToNextRound = currentPlayer && currentPlayer.status === 'queued';
      
      if (playerMovedToNextRound) {
        // Show prominent banner for current player moved to next round
        announcementContent.innerHTML = '<div style="background:#fbbf24;color:#0f172a;padding:16px;border-radius:8px;font-weight:600;border:2px solid #f59e0b;font-size:16px">' +
          '‚è≠Ô∏è <strong>' + currentPlayer.name + ' (Serial #' + currentPlayer.serial + ')</strong> has been moved to Round ' + (currentPlayer.round || 1) + '<br/>' +
          '<div style="margin-top:8px;font-size:14px;font-weight:normal">This player will be available in the next round of bidding.</div>' +
          '</div>';
        announcementCard.style.display = 'block';
      } else {
        // Get the most recent log entries
        const recentLogs = (st.logs || []).slice(-5).reverse();
        
        // Check for drop messages first
        const dropLogs = recentLogs.filter(log => 
          log.msg && log.msg.includes('DROP:')
        );
        
        if (dropLogs.length > 0) {
          const latestDrop = dropLogs[0];
          const dropMatch = latestDrop.msg.match(/DROP:\s*(.+?)\s+dropped from bidding on (.+?)\s+\(Serial\s+(\d+)\)/);
          if (dropMatch) {
            const captainName = dropMatch[1].trim();
            const playerName = dropMatch[2].trim();
            const serial = dropMatch[3];
            announcementContent.innerHTML = '<div style="background:#ef4444;color:#fff;padding:16px;border-radius:8px;font-weight:600;border:2px solid #dc2626;font-size:16px">' +
              'üö´ <strong>' + captainName + '</strong> dropped from bidding on <strong>' + playerName + ' (Serial #' + serial + ')</strong><br/>' +
              '<div style="margin-top:8px;font-size:14px;font-weight:normal">This captain is no longer participating in the bidding for this player.</div>' +
              '</div>';
            announcementCard.style.display = 'block';
          } else {
            announcementCard.style.display = 'none';
          }
        } else {
          // Check for admin actions
          const adminActionLogs = recentLogs.filter(log => 
            log.msg && (log.msg.includes('MOVED TO NEXT ROUND (Admin)') || log.msg.includes('MOVED TO NEXT ROUND:') || log.msg.includes('MOVED TO NEXT ROUND (Round') || log.msg.includes('FINISHED (Admin)'))
          );
          
          if (adminActionLogs.length > 0) {
            const latestAction = adminActionLogs[0];
            let announcementHtml = '';
            
            if (latestAction.msg.includes('MOVED TO NEXT ROUND (Admin)') || latestAction.msg.includes('MOVED TO NEXT ROUND:') || latestAction.msg.includes('MOVED TO NEXT ROUND (Round')) {
              // Try to extract round number from log message
              const roundMatch = latestAction.msg.match(/Round\s+(\d+)/);
              const round = roundMatch ? roundMatch[1] : '';
              const match = latestAction.msg.match(/MOVED TO NEXT ROUND(?: \(Admin\))?: (.+?)\s+\(Serial\s+(\d+)\)/);
              if (match) {
                const playerName = match[1].trim();
                const serial = match[2];
                const roundText = round ? ' Round ' + round : ' next round';
                announcementHtml = '<div style="background:#fbbf24;color:#0f172a;padding:16px;border-radius:8px;font-weight:600;border:2px solid #f59e0b;font-size:16px">' +
                  '‚è≠Ô∏è <strong>' + playerName + ' (Serial #' + serial + ')</strong> has been moved to' + roundText + '<br/>' +
                  '<div style="margin-top:8px;font-size:14px;font-weight:normal">This player will be available in the next round of bidding.</div>' +
                  '</div>';
              }
            } else if (latestAction.msg.includes('FINISHED (Admin)')) {
              const match = latestAction.msg.match(/FINISHED \(Admin\): (.+?) \(Serial \d+\) to (.+?) for (\d+)/);
              if (match) {
                announcementHtml = '<div style="background:#10b981;color:#fff;padding:12px;border-radius:8px;font-weight:600">' +
                  'üèÅ Admin Action: <span>' + match[1] + '</span> sold to <span style="font-weight:700">' + match[2] + '</span> for <span style="font-weight:700">' + match[3] + '</span>' +
                  '</div>';
              }
            }
            
            if (announcementHtml) {
              announcementContent.innerHTML = announcementHtml;
              announcementCard.style.display = 'block';
            } else {
              announcementCard.style.display = 'none';
            }
          } else {
            announcementCard.style.display = 'none';
          }
        }
      }
    }
    
    // Round Summary
    const roundSummaryEl = document.getElementById('roundSummaryContent');
    if (roundSummaryEl) {
      // Count players by status and round
      const soldCount = st.players.filter(p => p.status === 'sold').length;
      const pendingRound1 = st.players.filter(p => p.status === 'pending' && (p.round || 1) === 1).length;
      const pendingRound2 = st.players.filter(p => p.status === 'pending' && (p.round || 1) === 2).length;
      const pendingRound3 = st.players.filter(p => p.status === 'pending' && (p.round || 1) >= 3).length;
      const queuedRound2 = st.players.filter(p => p.status === 'queued' && (p.round || 1) === 2).length;
      const queuedRound3 = st.players.filter(p => p.status === 'queued' && (p.round || 1) === 3).length;
      const readyRound1 = st.players.filter(p => p.status === 'ready' && (p.round || 1) === 1).length;
      const readyRound2 = st.players.filter(p => p.status === 'ready' && (p.round || 1) === 2).length;
      const readyRound3 = st.players.filter(p => p.status === 'ready' && (p.round || 1) === 3).length;
      const biddingRound1 = st.players.filter(p => p.status === 'bidding' && (p.round || 1) === 1).length;
      const biddingRound2 = st.players.filter(p => p.status === 'bidding' && (p.round || 1) === 2).length;
      const biddingRound3 = st.players.filter(p => p.status === 'bidding' && (p.round || 1) === 3).length;
      
      // Calculate pending in each round (pending + queued + ready + bidding)
      const totalRound1 = pendingRound1 + readyRound1 + biddingRound1;
      const totalRound2 = pendingRound2 + queuedRound2 + readyRound2 + biddingRound2;
      const totalRound3 = pendingRound3 + queuedRound3 + readyRound3 + biddingRound3;
      
      roundSummaryEl.innerHTML = '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-top:12px">' +
        '<div style="padding:12px;background:#10b981;border-radius:8px;color:#fff">' +
          '<div style="font-size:24px;font-weight:700">' + soldCount + '</div>' +
          '<div style="font-size:14px;opacity:0.9">Players Bought</div>' +
        '</div>' +
        '<div style="padding:12px;background:#3b82f6;border-radius:8px;color:#fff">' +
          '<div style="font-size:24px;font-weight:700">' + totalRound1 + '</div>' +
          '<div style="font-size:14px;opacity:0.9">Pending Round 1</div>' +
        '</div>' +
        '<div style="padding:12px;background:#3b82f6;border-radius:8px;color:#fff">' +
          '<div style="font-size:24px;font-weight:700">' + totalRound2 + '</div>' +
          '<div style="font-size:14px;opacity:0.9">Pending Round 2</div>' +
        '</div>' +
        '<div style="padding:12px;background:#ef4444;border-radius:8px;color:#fff">' +
          '<div style="font-size:24px;font-weight:700">' + totalRound3 + '</div>' +
          '<div style="font-size:14px;opacity:0.9">Pending Round 3 (Admin)</div>' +
        '</div>' +
      '</div>';
    }
    
    const sold = st.players.filter(p=>p.status==='sold').reverse().slice(0, 10);
    document.getElementById('recent').innerHTML = sold.map(p=>{
      const winnerName = ((st.captains.find(c=>c.id===p.soldToCaptainId)||{}).name||'-');
      return '<div style="background:#1e293b;border:1px solid #334155;border-radius:8px;padding:10px;margin-bottom:8px">' +
        '<div style="display:flex;justify-content:space-between;align-items:center;gap:12px">' +
          '<div style="flex:1;min-width:0">' +
            '<div style="display:flex;gap:8px;align-items:center;margin-bottom:4px">' +
              '<span class="tag live-tag" style="padding:2px 6px">#' + p.serial + '</span>' +
              '<h4 class="live-h4" style="margin:0;word-wrap:break-word">' + p.name + '</h4>' +
            '</div>' +
          '</div>' +
          '<div style="text-align:right;flex-shrink:0;white-space:nowrap">' +
            '<div class="live-caption" style="color:#60a5fa;font-weight:600;margin-bottom:2px">' + winnerName + '</div>' +
            '<div class="live-caption" style="color:#94a3b8">(' + p.currentBid + ')</div>' +
          '</div>' +
        '</div>' +
      '</div>';
    }).join('');
    
    renderTeams(st);
  }
  
  function checkStateChanges(newState) {
    // Check for players that were just sold (status changed from 'bidding'/'ready' to 'sold')
    newState.players.forEach((player, index) => {
      if (player.status === 'sold' && player.soldToCaptainId) {
        const playerKey = `${player.serial}-${player.soldToCaptainId}`;
        
        // Check if this is a newly sold player (not in our tracking set)
        if (!previousState.soldPlayers.has(playerKey)) {
          // Also check if status actually changed (was bidding/ready before)
          const prevPlayer = previousState.players.find(p => p.serial === player.serial);
          const wasBidding = prevPlayer && (prevPlayer.status === 'bidding' || prevPlayer.status === 'ready');
          
          if (wasBidding || !prevPlayer) {
            previousState.soldPlayers.add(playerKey);
            
            const winner = newState.captains.find(c => c.id === player.soldToCaptainId);
            const winnerName = winner ? winner.name : 'Unknown';
            const price = player.currentBid || player.basePrice || 0;
            
            // Play clapping sound and announce
            playSound('sold');
            setTimeout(() => {
              speak(`${winnerName} won ${player.name} for ${price}`, 'high');
            }, 500);
          }
        }
      }
    });
    
    // Check for new player
    if (newState.currentIndex !== previousState.currentIndex) {
      if (newState.currentIndex != null) {
        const p = newState.players[newState.currentIndex];
        if (p) {
          playSound('newPlayer');
          setTimeout(() => {
            speak(`${p.name} is now up for bidding`, 'high');
          }, 300);
        }
      }
    }
    
    // Check for new logs (bids, drops, sales, etc.)
    if (newState.logs && newState.logs.length > 0) {
      const newLogs = newState.logs.slice(previousState.logs.length);
      
      newLogs.forEach(log => {
        if (!log.msg) return;
        const msg = log.msg;
        
        if (msg.includes('BASE PRICE CLAIMED')) {
          playSound('basePrice');
          const match = msg.match(/BASE PRICE CLAIMED: (.+?) ‚Üí/);
          if (match) {
            setTimeout(() => {
              speak(`${match[1]} claimed base price`, 'normal');
            }, 200);
          }
        } else if (msg.includes('BID:')) {
          playSound('bid');
          const match = msg.match(/BID: (.+?) ‚Üí .+? @ (\d+)/);
          if (match) {
            setTimeout(() => {
              speak(`${match[1]} bid ${match[2]}`, 'normal');
            }, 200);
          }
        } else if (msg.includes('DROP:')) {
          playSound('drop');
          const match = msg.match(/DROP: (.+?) dropped/);
          if (match) {
            setTimeout(() => {
              speak(`${match[1]} dropped from bidding`, 'normal');
            }, 200);
          }
        } else if (msg.includes('SOLD:') || msg.includes('FINISHED (Admin)') || msg.includes('AUTO-ASSIGNED')) {
          // Extract player and winner info from log message
          let playerName = '';
          let winnerName = '';
          let price = '';
          
          // Try different log message formats
          const soldMatch = msg.match(/(?:SOLD|FINISHED \(Admin\)|AUTO-ASSIGNED): (.+?) \(Serial \d+\)(?: to (.+?) for (\d+)| for (\d+))?/);
          if (soldMatch) {
            playerName = soldMatch[1];
            winnerName = soldMatch[2] || soldMatch[4] || 'Unknown';
            price = soldMatch[3] || soldMatch[5] || '0';
          }
          
          // If we have the info, announce it (but don't duplicate if already announced via status check)
          if (playerName && winnerName && price) {
            // The status check above will handle the announcement, but this ensures we catch it from logs too
            // We'll let the status check handle it to avoid duplicates
          }
        } else if (msg.includes('MOVED TO NEXT ROUND (Admin)') || msg.includes('MOVED TO NEXT ROUND:')) {
          playSound('adminAction');
          const match = msg.match(/MOVED TO NEXT ROUND(?: \(Admin\))?: (.+?)\s+\(Serial/);
          if (match) {
            setTimeout(() => {
              speak(`${match[1]} moved to next round`, 'normal');
            }, 200);
          }
        } else if (msg.includes('PLAYER BROUGHT TO AUCTION') || msg.includes('BIDDING STARTED')) {
          playSound('newPlayer');
          const match = msg.match(/(?:PLAYER BROUGHT TO AUCTION|BIDDING STARTED): (.+?)\s+\(Serial/);
          if (match) {
            setTimeout(() => {
              speak(`${match[1]} ${msg.includes('BIDDING STARTED') ? 'bidding started' : 'brought to auction'}`, 'normal');
            }, 200);
          }
        } else if (msg.includes('VOIDED')) {
          playSound('adminAction');
        } else if (msg.includes('FINISHED (Admin)')) {
          playSound('adminAction');
          const match = msg.match(/FINISHED \(Admin\): (.+?) \(Serial \d+\) to (.+?) for (\d+)/);
          if (match) {
            setTimeout(() => {
              speak(`Admin finished: ${match[2]} won ${match[1]} for ${match[3]}`, 'high');
            }, 200);
          }
        }
      });
    }
    
    // Check for timer warnings (last 10 seconds)
    if (newState.currentIndex != null) {
      const p = newState.players[newState.currentIndex];
      if (p && p.biddingEndsAt && p.status === 'bidding') {
        const timeLeft = Math.max(0, p.biddingEndsAt - Date.now());
        const secondsLeft = Math.ceil(timeLeft / 1000);
        
        // Play warning sound at 10, 5, 3, 2, 1 seconds (only once per second)
        if (secondsLeft !== previousState.lastTimerSecond && 
            (secondsLeft === 10 || secondsLeft === 5 || secondsLeft === 3 || secondsLeft === 2 || secondsLeft === 1)) {
          playSound('timerWarning');
          if (secondsLeft <= 3) {
            speak(`${secondsLeft} second${secondsLeft !== 1 ? 's' : ''} remaining`, 'high');
          }
          previousState.lastTimerSecond = secondsLeft;
        }
      } else {
        previousState.lastTimerSecond = null;
      }
    } else {
      previousState.lastTimerSecond = null;
    }
    
    // Update previous state (preserve lastTimerSecond and soldPlayers)
    previousState = {
      currentIndex: newState.currentIndex,
      players: [...newState.players],
      logs: [...(newState.logs || [])],
      lastTimerSecond: previousState.lastTimerSecond,
      soldPlayers: previousState.soldPlayers
    };
  }
  
  // Timer update function removed - timer is not displayed on live pages
  // Pause info is shown directly in the HTML and updated on each render
  
  // Background music functionality - Light Classical
  let backgroundMusic = null;
  let isMusicPlaying = false;
  let musicInterval = null;
  
  // Light classical melody pattern (inspired by classical music)
  const classicalMelody = [
    { freq: 261.63, duration: 0.6 }, // C4
    { freq: 293.66, duration: 0.6 }, // D4
    { freq: 329.63, duration: 0.6 }, // E4
    { freq: 349.23, duration: 0.6 }, // F4
    { freq: 392.00, duration: 0.8 }, // G4
    { freq: 349.23, duration: 0.6 }, // F4
    { freq: 329.63, duration: 0.6 }, // E4
    { freq: 293.66, duration: 0.6 }, // D4
    { freq: 261.63, duration: 0.8 }, // C4
    { freq: 293.66, duration: 0.6 }, // D4
    { freq: 329.63, duration: 0.6 }, // E4
    { freq: 349.23, duration: 0.6 }, // F4
    { freq: 392.00, duration: 0.8 }, // G4
    { freq: 440.00, duration: 0.6 }, // A4
    { freq: 392.00, duration: 0.6 }, // G4
    { freq: 349.23, duration: 0.8 }, // F4
  ];
  
  function createBackgroundMusic() {
    const audioContext = getAudioContext();
    
    const playClassicalNote = (note, time) => {
      if (!isMusicPlaying) return;
      
      const now = audioContext.currentTime + time;
      
      // Main melody note
      const osc1 = audioContext.createOscillator();
      const gain1 = audioContext.createGain();
      osc1.type = 'sine';
      osc1.frequency.value = note.freq;
      gain1.gain.setValueAtTime(0, now);
      gain1.gain.linearRampToValueAtTime(0.06, now + 0.05);
      gain1.gain.linearRampToValueAtTime(0.06, now + note.duration - 0.1);
      gain1.gain.linearRampToValueAtTime(0, now + note.duration);
      osc1.connect(gain1);
      gain1.connect(audioContext.destination);
      osc1.start(now);
      osc1.stop(now + note.duration);
      
      // Add harmony for richer sound
      const harmonyFreq = note.freq * 0.75; // Perfect fourth below for classical harmony
      const osc2 = audioContext.createOscillator();
      const gain2 = audioContext.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = harmonyFreq;
      gain2.gain.setValueAtTime(0, now);
      gain2.gain.linearRampToValueAtTime(0.03, now + 0.05);
      gain2.gain.linearRampToValueAtTime(0.03, now + note.duration - 0.1);
      gain2.gain.linearRampToValueAtTime(0, now + note.duration);
      osc2.connect(gain2);
      gain2.connect(audioContext.destination);
      osc2.start(now);
      osc2.stop(now + note.duration);
    };
    
    const playMelody = () => {
      if (!isMusicPlaying) return;
      
      let currentTime = 0;
      const melody = classicalMelody;
      
      melody.forEach((note) => {
        playClassicalNote(note, currentTime);
        currentTime += note.duration + 0.1; // Small gap between notes
      });
    };
    
    return { audioContext, playMelody };
  }
  
  function startBackgroundMusic() {
    if (isMusicPlaying) return;
    try {
      const music = createBackgroundMusic();
      backgroundMusic = music;
      
      // Resume audio context if suspended
      if (music.audioContext.state === 'suspended') {
        music.audioContext.resume();
      }
      
      // Play melody - it loops automatically
      const melodyDuration = classicalMelody.reduce((sum, note) => sum + note.duration + 0.1, 0) * 1000;
      music.playMelody(); // Play immediately
      musicInterval = setInterval(() => {
        if (isMusicPlaying && music.audioContext.state === 'running') {
          music.playMelody();
        }
      }, melodyDuration);
      
      isMusicPlaying = true;
    } catch (e) {
      console.log('Background music not available:', e);
    }
  }
  
  // Start background music after audio is initialized
  document.addEventListener('click', function() {
    setTimeout(startBackgroundMusic, 500);
  }, { once: true });
  document.addEventListener('touchstart', function() {
    setTimeout(startBackgroundMusic, 500);
  }, { once: true });
  
  let st = null;
  sock.on('state:update', (state) => {
    console.log('üìä State update received:', state ? 'State received successfully' : 'Empty state');
    st = state;
    render(state);
  });
  
  // Listen for admin read-out announcements
  sock.on('announcement:readOut', (data) => {
    if (data && data.text) {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }
      speak(data.text, data.priority || 'high');
    }
  });
  
  // Initialize audio on user interaction
  document.addEventListener('click', function initAudio() {
    getAudioContext();
  }, { once: true });
  </script>
</body>
</html>

